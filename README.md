Writeup for CMPE 283 Assignment 1

Steps undertaken for Assignment 1:

Installed VMWare workstation player 16 on my windows machine.

Downloaded ubuntu OS installer iso/disk image file

Installed Image on Workstation player

Installed git on Ubuntu VM

Set permissions to grant superuser access to default user profile

Downloaded relevant course files on VM

Changed ownership of fork-cloned linux file and downloaded course files (.c file and makefile) to default user

Realized that nested virtualization was not enabled on VM

Did a lot of research on trying to narrow down why the VM controls were not being enabled on the VMware workstation Player and Windows 10

Learned that it was because of Hyper-V modules installed in windows 10. Ran the command “bcdedit /set hypervisorlaunchtype off” in powershell in admin mode to resolve the issue. (VMWare Customer Connect, 2020)

Re-enabled VMX controls for VM in Workstation Player. It was done using “Player> Manage> Virtual Machine Settings> Processors> Check “Virtualize Intel VT-x/EPT or AMD-V/RVI”

Verified whether virtualization was enabled in the VM environment by calling “lscpu” command on the VM terminal.

Went through and tried to understand the “cmpe283-1.c” file.

Installed gcc and vim to make processing/coding the “cmpe283-1.c” file easier.

Tried to build the make file as suggested in the assignment video.

Went ahead and tried to install

Installed libssl-dev, libelf, libdwarf, and a few more tools using the “sudo apt-get install” commands over the course of the build process. I used the fatal errors to determine which exact packets were missing. I remember there used to be a command in linux to auto-install all missing packets and tools required for a build/process but have forgotten what it was.

Tweaked the copied linux config files from boot into linux directory to modify certificate checks as it was causing build errors in the kernel make and/or module make commands ("Agora" & "slm", n.d.). Had to remove certain attributes and comment out some lines referencing debian certificates which were not installed. This caused the build to generate new certificates which resolved the issue. The certificates seemed to be generated by/using the x509 protocol.

Resolved various errors that arose in the linux make process such as the absence of “dwarves” by installing “dwarves” into the VM. I initially thought this “pahole” issue would be resolved using the “libdwarf” install but was wrong.

Called the make command various times on the linux build. This took up a lot of the time as each build, even with 4 processors working on it simultaneously, would take at least an hour or so to complete. At this point, the modules have been successfully made, the oldconfig has been made (with default answers to all config questions by pressing enter instead of “y/n”), the prepare file has been made and tried, the provided makeFile has been made. The recurring issue lies when trying to make the linux kernel file within the fork-clone directory.

Called “sudo make INSTALL_MOD_STRIP=1 modules_install” to collect all modules and repackage them into the lib folder for easier deployment. This also ensures that the debug info is stripped so that the file size is substantially reduced.

Called “sudo make install” to finally build the kernel

Used “sudo reboot” to reboot the machine and run the latest kernel on VM

Called “make” again in the directory preceding the linux directory. It ran into the same issue as the one seen in the assignment 1 video. Installed module licenses by adding the “MODULE_LICENSE(“GPL v2”);” statement to the cmpe283-1.c file.

Successfully created the kernel object and then called “sudo insmod cmpe283-1.ko”.

Verified that the kernel object was loaded successfully using the “lsmod | grep cmpe283” command

Called dmesg to get the following output: <Image missing; was inserted in google doc>

Made a cmpe283 directory inside the linux folder and stored the final versions of the Makefile and cmpe283-1.c files in it. Committed the changes (i.e. addition of both files) to the local repo. Generated the personal token on github, logged in and entered the personal token as the password to push the changes to github repo. The protocol involving the personal token has been made mandatory since August 13, 2021 and was not mentioned in the assignment instruction video (just a heads up for the next semester classes!).



References
"Agora", & "slm". (n.d.). Attempting to compile kernel yields a certification error - Unix & Linux Stack Exchange. Unix StackExchange. Retrieved November 10, 2021, from https://unix.stackexchange.com/questions/293642/attempting-to-compile-kernel-yields-a-certification-error

VMWare Customer Connect. (2020, September 9). "VMware Workstation and Device/Credential Guard are not compatible" error in VMware Workstation on Windows 10 host (2146361) | VMware KB. VMware Knowledge Base. Retrieved November 10, 2021, from https://kb.vmware.com/s/article/2146361

—-----------------------------------------------------------------------------------------------------------------

Assignment 2 write-up

—-----------------------------------------------------------------------------------------------------------------

Pavan Karthik Gollakaram (015945670)

Overall, I handled the testing phase of the VM by using my team member’s VM setup, as my own VM kept running into unending issues.
I ran the CPUID command and tested the KV responses from the VM for each register whenever the handle_exit/emulate_cpu_Id methods were passed with the values of  0x4fffffff and 0x4ffffffe using the ‘sudo cpuid -l 0x4ffffffe’ commands.
All we could get were mixed results for the build as we struggled with the initial setup of the VM environment and also because it simply wouldn’t build the ‘INSTALL MOD_STRIP=1 install_modules’ command.
‘Make’ and ‘make modules’ are executed successfully but ‘kvm=>kvm_inte->kvm’ command would throw cyclic dependency errors every time.
We spend hours collectively researching a solution for this problem but were unable to resolve the issue. 

—-----------------------------------------------------------------------------------------------------------------

Shahbaz Singh Mansahia (010027459)
I basically tried to code the exit_handler code and the cpuid’s emulate_cpuid code. Created some if-else statements and skeletal code for both the assignments. Managed to debug most issues as we were simply told about the extern command but did not know that we had to also explicitly export the variables using the EXPORT_SYMBOL_GPL() commands. I initially assumed these would apss regardless since c++ tends to share globals across c files as long as they are imported. I tried to install the nested VM and asked Pavan for help with testing and researching how to pass the cpuid command with the relevant parameters and test the code I wrote. We struggled mostly because, despite researching the issue of the cyclic dependency, we got nowhere. I hope I can resolve this issue and succeed in the next assignment. Most of the issues stemmed from the configuration of the system and the compilation time for the linux source code files rather than the code complexity of the code since documentation can be studied but if you don’t have experience with C, and on top of that try to setup a nested VM environment with a custom VMM, one who’s source code you don’t completely understand, it gets very hard to find any answers or support for any problems one runs into.

—-----------------------------------------------------------------------------------------------------------------

Added if-else statements to the ‘kvm_emulate-cpuid()’ function in cpuid.c as required by the assignment(s) for each of the assignment clauses.

Initialized and added the total_exits variable to the vmx.c file in the ‘__vmx_handle_exit()’ method to tally the total number of exits taken by the VM.

Defined the total_exits variable within the vmx_handle_exit method mentioned earlier but initialized as an unsigned 32 bit variable right above the method definition in the section labelled “Tweaked code”. This effectively turned total_exits into a global variable for the scope of that file.

Declared the total_exits variable as an extern uint32_t variable inside the cpuid.c file under the cpuid function.

Researched the nature of the errors causing the builds to fail. Eventually figured out that it was being caused because total_exits wasn’t being exported properly. Utilized the ‘EXPORT_SYMBOL_GPL()’ method to export the variable to cpuid file.

Built the code successfully. It still fails at the second build/repacking command (‘make  INSTALL_MOD_STRIP=1 modules_install && make install’) though. 

Added further code to calculate the time spent exiting. Used the same EXPORT_SYMBOL_GPL() method to export the 2 uint64_t values that stored the clock timer values from the VCPUs using the rdtsc() method.

Researched on how to split up the uint64_t variables into uint32_t variables as the registers are 32 bit.

Found the answer in the assignment 1 coding file. Utilized similar logic to how pr_info() method for splitting/using the lo and hi values.

Developed the code to calculate the total time spent in the exit handler and assigned it to the necessary registers.

Built the code successfully using the ‘make -j 8 modules’ command but again, failed at repackaging. I am assuming that the code is error free but the linux package build fails. It is still the same issue as the old ‘kvm’ and ‘kvm->intel’ cyclical dependency issue. As far as I could tell, while I could not find any reference to this exact dependency, I did find some data on the fact that a similar dependency was being caused by updates to linux builds, etc.

Installed virt-Manager, qemu-kvm, libvirt-daemon-system, libvirt-clients, bridge-utils and virtinst to run the nested VM.

Tried to chcek nested virtualization and kvm status but got “unknown symbol” issues for all the custom variables used in the cpuid.c and vmx.c files. The “kvm->kvm_intel->kvm” cyclic dependency still causes an error in the ‘make INSTALL_MOD_STRIP=1 install_modules” command

Installed the nested VM and researched installing custom KVM in the initial VM to del/test with the nested VM using out custom code

Installed the cpuid package in the nested VM and conducted tests.

—-----------------------------------------------------------------------------------------------------------------

Assignment 3 write-up

—-----------------------------------------------------------------------------------------------------------------
Pavan Karthik Gollakaram (015945670)

I worked with Shahbaz in setting up the code of cpuid.c and vmx.c. We examined Intel's SDM to view the available exit codes and gathered the required code to print out the supported KVM exit codes and what numbers are associated with the exit codes. 

—-----------------------------------------------------------------------------------------------------------------

Shahbaz Singh Mansahia (010027459)

Coded the D leaf node and installed the kvm modules on my local machine this time. Also rewrote the lost data from the force push from last week to keep assignment documentation intact with the help of Pavan. Debugged the virtual network adapter issues that arose during this particular assignment. Also worked with Pavan for implementing the C leaf of the assignment. Tested using the cpuid function in the nested VM with mixed results as the code, despite building and installing, and the kvm and kvm_intel modules being mod-probe’d successfully, would not translate to cpuid outputs in the nested VM terminal (when using the cpuid package installed and tested using “cpuid -l 0x4ffffff<leaf>; with <leaf> being the specific code value passed to the function as instructed in the assignment).
—-----------------------------------------------------------------------------------------------------------------

Setup the virt-manager and other dependencies for the nested VM in the previous assignment but forgot to mention it/ran out of time/issues during the last 15 minutes so I couldn’t mention it.

Swapped the extern declaration to vmx.c and the variable declaration to cpuid.c and that has fixed the install issue.

Re-tweaked the code in the vmx.c file to match the new code format. Initially, the code was based on the kvm_vmx_max_exit_handlers value as defined in the vmx.c file but now have had to hard code the array size to 69 to match SDM documentation.

The if clause already defined (wrote this code as a safety net initially) to return 0 and 0x4fffffff values in registers is now more relevant. 

Built the modules and linux files again.

Switched to super-user mode using ‘sudo bash’ command.

Installed the modules successfully using ‘sudo make INSTALL_MOD_STRIP=1 modules_install && make install’ command in terminal.

Checked the kvm status using ‘kvm-ok’ and then ran the installed kvm module using ‘modprobe intel_kvm’ and ‘kvm’.

Rebooted machine to make sure installed changes are preloaded.

Changed the virtual machine manager cpu and memory config for nested vm to ensure smoother and faster functioning.

Ran into an issue where the networking interface for the VM was down due to a suspend-resume crash

Spent a few hours researching how to fix the issue and fixed it using ‘nmcli networking on’ . The following link helped me resolve the issue: “https://askubuntu.com/questions/1218616/after-a-restart-due-to-a-system-crash-the-ethernet-interface-is-disappeared-how” ("AndreaNobili", 2020)

Used ‘rmmod’ on ‘kvm’ and ‘kvm_intel’ modules to unload them and then loaded them back again using ‘modprobe’.

After getting rid of the cyclical dependency issues, and extensive debugging of the code and system configuration, we were unable to get the code to display in cpuid calls from the nested vm.

Decided to attach all the setup and configuration build snapshots to document our progress on the assignments and project overall. Getting it to build was some sort of feat I guess. We are aware that the code does not successfully check for disabled controls from the VM but without an active code display (despite trying printk and pr_info messages we were unable to find them in the dmesg log or anywhere else), we could only work on it as much as we did.

—---------------------------------------------------------------------------------------------------------------------------

Q1) Comment on the frequency of exits – does the number of exits increase at a stable rate? Or are there more exits performed during certain VM operations? Approximately how many exits does a full VM boot entail? 

A1) Since we did not have any displays indicating or giving us data on this, I would like to point out that one of the highest tolls was the device interrupts (especially the network adapter). I say this because when the network adapter was disabled by the VM and on the path to re-enable those controls, I noticed a substantial performance boost in the VM which could only be explained by no constant network device interrupts. Another noticeable performance discrepancy was when the VM(s) were left on idle. When the VM was not doing anything and I’d switch windows, it’d lag a bit before coming back to normal speeds. This was probably due to the halt (HLT) interrupts. At multiple points while working on the assignments, when I’d switch away from VM window (with machine on idle) and come back after long period of time (about 30 minutes or so), there would be a very noticeable lag initially. Sometimes it could be explained by the lock screen being triggered; I feel like it was due to a combination of multiple factors like process scheduling on the host machine, the HLT interrupts/loop on the VM(s) and how those interrupts/loops function on a VM lock screen.

Q2) Of the exit types defined in the SDM, which are the most frequent? Least?

A2) I’d say the device interrupts and HLT interrupts were the most common. Again, this is coming not from displayed feedback from the machine but from intuition based on what we learned in the course so far and observed machine behavior over the course of the assignments.

—---------------------------------------------------------------------------------------------------------------------------


References
"AndreaNobili". (2020, March 19). After a restart due to a system crash the ethernet interface is disappeared. How to restore it? Ask Ubuntu. Retrieved November 29, 2021, from https://askubuntu.com/questions/1218616/after-a-restart-due-to-a-system-crash-the-ethernet-interface-is-disappeared-how


